<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./assets/bootstrap/css/bootstrap.min.css"/>
</head>
<body>
<div class="progress" style="height: 20px;">
    <div id="progress" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0"
         aria-valuemax="100"></div>
</div>
<script src="./assets/bootstrap/js/bootstrap.min.js"></script>
<script>
    let audioContext = null
    let meter = null
    let mediaStreamSource = null
    const progress = document.getElementById('progress');

    window.AudioContext = window.AudioContext || window.webkitAudioContext
    audioContext = new AudioContext()

    function onMicrophoneDenied() {
        alert('Stream generation failed.')
    }

    /**
     * Callback triggered if the access to the microphone is granted
     */
    function onMicrophoneGranted(stream) {
        mediaStreamSource = audioContext.createMediaStreamSource(stream)
        meter = createAudioMeter(audioContext)
        mediaStreamSource.connect(meter)
        onLevelChange()
    }

    /**
     * This function is executed repeatedly
     */
    function onLevelChange() {
        if (meter.checkClipping()) {
            progress.classList.add('bg-danger')
        } else {
            progress.classList.remove('bg-danger')
        }
        progress.setAttribute("aria-valuenow", meter.volume * 100 + "%")
        progress.style.width = meter.volume * 100 + "%";
    }

    setInterval(onLevelChange, 100);

    // Try to get access to the microphone
    try {

// Retrieve getUserMedia API with all the prefixes of the browsers
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia

// Ask for an audio input
        navigator.getUserMedia({
                audio: {
                    mandatory: {
                        googEchoCancellation: 'false',
                        googAutoGainControl: 'false',
                        googNoiseSuppression: 'false',
                        googHighpassFilter: 'false'
                    },
                    optional: []
                },
            },
            onMicrophoneGranted,
            onMicrophoneDenied
        )
    } catch (e) {
        alert('getUserMedia threw exception :' + e)
    }

    function createAudioMeter(audioContext, clipLevel, averaging, clipLag) {
        var processor = audioContext.createScriptProcessor(512)
        processor.onaudioprocess = volumeAudioProcess
        processor.clipping = false
        processor.lastClip = 0
        processor.volume = 0
        processor.clipLevel = clipLevel || 0.98
        processor.averaging = averaging || 0.95
        processor.clipLag = clipLag || 750

// this will have no effect, since we don't copy the input to the output,
// but works around a current Chrome bug.
        processor.connect(audioContext.destination)

        processor.checkClipping =
            function () {
                if (!this.clipping)
                    return false
                if ((this.lastClip + this.clipLag) < window.performance.now())
                    this.clipping = false
                return this.clipping
            }

        processor.shutdown =
            function () {
                this.disconnect()
                this.onaudioprocess = null
            }

        return processor
    }

    function volumeAudioProcess(event) {
        var buf = event.inputBuffer.getChannelData(0)
        var bufLength = buf.length
        var sum = 0
        var x

// Do a root-mean-square on the samples: sum up the squares...
        for (var i = 0; i < bufLength; i++) {
            x = buf[i]
            if (Math.abs(x) >= this.clipLevel) {
                this.clipping = true
                this.lastClip = window.performance.now()
            }
            sum += x * x
        }

// ... then take the square root of the sum.
        var rms = Math.sqrt(sum / bufLength)

// Now smooth this out with the averaging factor applied
// to the previous sample - take the max here because we
// want "fast attack, slow release."
        this.volume = Math.max(rms, this.volume * this.averaging)
    }
</script>
</body>
</html>
